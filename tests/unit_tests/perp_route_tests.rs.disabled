// ==============================================================================
// TEMPORARILY DISABLED - PerpManager Refactor in Progress
// ==============================================================================
//
// This file is disabled due to the migration from PerpHook to PerpManager architecture.
//
// **What changed:**
// - Request models now require module addresses (fees, margin_ratios, lockup_period, etc.)
// - DeployPerpForBeaconRequest now has 5 additional required fields
// - DepositLiquidityForPerpRequest has new optional fields (holder, max_amt0_in, max_amt1_in)
//
// **Invalid test data in this file:**
// - Lines 23-25: DeployPerpForBeaconRequest only has beacon_address (missing module addresses)
// - All test instances of DeployPerpForBeaconRequest need updating
// - All test instances of DepositLiquidityForPerpRequest need new optional fields
//
// **TODO:**
// Update all test request objects to include new required/optional fields for PerpManager.
//
// **To re-enable:**
// 1. Add module address fields to all DeployPerpForBeaconRequest instances
// 2. Add optional fields (holder, max_amt0_in, max_amt1_in) to DepositLiquidityForPerpRequest
// 3. Rename file to remove .disabled extension
// ==============================================================================

// Comprehensive unit tests for perp routes

use alloy::primitives::{Address, FixedBytes};
use rocket::serde::json::Json;
use rocket::{State, http::Status};
use std::str::FromStr;
use the_beaconator::guards::ApiToken;
use the_beaconator::models::{
    BatchDeployPerpsForBeaconsRequest, BatchDepositLiquidityForPerpsRequest,
    DeployPerpForBeaconRequest, DepositLiquidityForPerpRequest,
};
use the_beaconator::routes::perp::{
    batch_deploy_perps_for_beacons, batch_deposit_liquidity_for_perps,
    deploy_perp_for_beacon_endpoint, deposit_liquidity_for_perp_endpoint,
};

#[tokio::test]
async fn test_deploy_perp_invalid_beacon_address() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DeployPerpForBeaconRequest {
        beacon_address: "invalid_address".to_string(),
    });

    let result = deploy_perp_for_beacon_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deploy_perp_empty_beacon_address() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DeployPerpForBeaconRequest {
        beacon_address: "".to_string(),
    });

    let result = deploy_perp_for_beacon_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deploy_perp_short_address() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DeployPerpForBeaconRequest {
        beacon_address: "0x123".to_string(),
    });

    let result = deploy_perp_for_beacon_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deploy_perp_valid_address_network_failure() {
    let mock_provider = crate::test_utils::create_mock_provider_with_network_error();
    let app_state = crate::test_utils::create_test_app_state_with_provider(mock_provider);
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DeployPerpForBeaconRequest {
        beacon_address: "0x1234567890123456789012345678901234567890".to_string(),
    });

    // Should fail deterministically due to mock provider
    let result = deploy_perp_for_beacon_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::InternalServerError);
}

#[tokio::test]
async fn test_deposit_liquidity_invalid_perp_id() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "not_a_hex_string".to_string(),
        margin_amount_usdc: "500000000".to_string(),
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deposit_liquidity_empty_perp_id() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "".to_string(),
        margin_amount_usdc: "500000000".to_string(),
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deposit_liquidity_invalid_margin_amount() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "0x1234567890123456789012345678901234567890123456789012345678901234".to_string(),
        margin_amount_usdc: "not_a_number".to_string(),
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deposit_liquidity_zero_margin() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "0x1234567890123456789012345678901234567890123456789012345678901234".to_string(),
        margin_amount_usdc: "0".to_string(),
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_deposit_liquidity_negative_margin() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "0x1234567890123456789012345678901234567890123456789012345678901234".to_string(),
        margin_amount_usdc: "-100".to_string(),
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_batch_deploy_perps_zero_count() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(BatchDeployPerpsForBeaconsRequest {
        beacon_addresses: vec![],
    });

    let result = batch_deploy_perps_for_beacons(request, token, state).await;

    // Should fail with BadRequest - empty arrays not allowed (1-10 limit)
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_batch_deploy_perps_invalid_address_in_batch() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(BatchDeployPerpsForBeaconsRequest {
        beacon_addresses: vec![
            "0x1234567890123456789012345678901234567890".to_string(),
            "invalid_address".to_string(),
            "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd".to_string(),
        ],
    });

    let result = batch_deploy_perps_for_beacons(request, token, state).await;

    // Should return OK with partial results
    assert!(result.is_ok());
    let response = result.unwrap().into_inner();

    if let Some(data) = response.data {
        // Should have some failed deployments due to invalid address
        assert!(data.failed_count > 0);
        assert!(!data.errors.is_empty());
    }
}

#[tokio::test]
async fn test_batch_deposit_liquidity_empty_deposits() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(BatchDepositLiquidityForPerpsRequest {
        liquidity_deposits: vec![],
    });

    let result = batch_deposit_liquidity_for_perps(request, token, state).await;

    // Should fail with BadRequest - empty arrays not allowed (1-10 limit)
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), Status::BadRequest);
}

#[tokio::test]
async fn test_batch_deposit_liquidity_mixed_valid_invalid() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(BatchDepositLiquidityForPerpsRequest {
        liquidity_deposits: vec![
            DepositLiquidityForPerpRequest {
                perp_id: "0x1234567890123456789012345678901234567890123456789012345678901234"
                    .to_string(),
                margin_amount_usdc: "500000000".to_string(),
            },
            DepositLiquidityForPerpRequest {
                perp_id: "invalid_perp_id".to_string(),
                margin_amount_usdc: "500000000".to_string(),
            },
            DepositLiquidityForPerpRequest {
                perp_id: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcd"
                    .to_string(),
                margin_amount_usdc: "invalid_amount".to_string(),
            },
        ],
    });

    let result = batch_deposit_liquidity_for_perps(request, token, state).await;

    // Should return OK with partial results
    assert!(result.is_ok());
    let response = result.unwrap().into_inner();

    if let Some(data) = response.data {
        // Should have failures due to invalid inputs
        assert!(data.failed_count > 0);
        assert!(!data.errors.is_empty());
    }
}

#[tokio::test]
async fn test_deposit_liquidity_below_minimum() {
    let mock_provider = crate::test_utils::create_mock_provider_with_network_error();
    let app_state = crate::test_utils::create_test_app_state_with_provider(mock_provider);
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    // Test with amount below typical minimum (1 USDC = 1,000,000)
    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "0x1234567890123456789012345678901234567890123456789012345678901234".to_string(),
        margin_amount_usdc: "100".to_string(), // 0.0001 USDC
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;

    // Should fail deterministically (validation error or mock provider error)
    assert!(result.is_err());
}

#[tokio::test]
async fn test_deploy_perp_address_case_sensitivity() {
    let mock_provider = crate::test_utils::create_mock_provider_with_network_error();
    let app_state = crate::test_utils::create_test_app_state_with_provider(mock_provider);
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    // Test with uppercase hex address
    let request = Json(DeployPerpForBeaconRequest {
        beacon_address: "0xABCDEFABCDEFABCDEFABCDEFABCDEFABCDEFABCD".to_string(),
    });

    let result = deploy_perp_for_beacon_endpoint(request, token, state).await;

    // Should handle case-insensitive addresses but fail deterministically due to mock provider
    assert!(result.is_err());
}

#[tokio::test]
async fn test_deposit_liquidity_perp_id_without_0x_prefix() {
    let mock_provider = crate::test_utils::create_mock_provider_with_network_error();
    let app_state = crate::test_utils::create_test_app_state_with_provider(mock_provider);
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let request = Json(DepositLiquidityForPerpRequest {
        perp_id: "1234567890123456789012345678901234567890123456789012345678901234".to_string(),
        margin_amount_usdc: "500000000".to_string(),
    });

    let result = deposit_liquidity_for_perp_endpoint(request, token, state).await;

    // Hex strings without 0x prefix might parse but will fail deterministically
    assert!(result.is_err());
}

#[tokio::test]
async fn test_batch_deploy_duplicate_addresses() {
    let app_state = crate::test_utils::create_simple_test_app_state();
    let state = State::from(&app_state);
    let token = ApiToken("test_token".to_string());

    let duplicate_address = "0x1234567890123456789012345678901234567890".to_string();
    let request = Json(BatchDeployPerpsForBeaconsRequest {
        beacon_addresses: vec![
            duplicate_address.clone(),
            duplicate_address.clone(),
            duplicate_address,
        ],
    });

    let result = batch_deploy_perps_for_beacons(request, token, state).await;

    // Should handle duplicates (may deploy multiple or fail)
    assert!(result.is_ok());
}

#[test]
fn test_perp_id_parsing_valid() {
    // Test FixedBytes<32> parsing
    let valid_perp_id = "0x1234567890123456789012345678901234567890123456789012345678901234";
    let result = FixedBytes::<32>::from_str(valid_perp_id);
    assert!(result.is_ok());
}

#[test]
fn test_perp_id_parsing_invalid_length() {
    // Test with incorrect length (too short)
    let invalid_perp_id = "0x123456";
    let result = FixedBytes::<32>::from_str(invalid_perp_id);
    assert!(result.is_err());
}

#[test]
fn test_margin_amount_parsing_valid() {
    let amounts = vec!["0", "1", "1000000", "999999999999"];
    for amount in amounts {
        let result = amount.parse::<u128>();
        assert!(result.is_ok(), "Failed to parse: {amount}");
    }
}

#[test]
fn test_margin_amount_parsing_invalid() {
    let invalid_amounts = vec!["abc", "-100", "1.5", "100,000", ""];
    for amount in invalid_amounts {
        let result = amount.parse::<u128>();
        assert!(result.is_err(), "Should fail to parse: {amount}");
    }
}

#[test]
fn test_beacon_address_parsing() {
    // Valid addresses
    let valid_addresses = vec![
        "0x0000000000000000000000000000000000000000",
        "0x1234567890123456789012345678901234567890",
        "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
    ];

    for addr in valid_addresses {
        let result = Address::from_str(addr);
        assert!(result.is_ok(), "Failed to parse valid address: {addr}");
    }

    // Invalid addresses
    let invalid_addresses = vec![
        "",
        "0x",
        "0x123",
        "not_an_address",
        "0xGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG",
    ];

    for addr in invalid_addresses {
        let result = Address::from_str(addr);
        assert!(
            result.is_err(),
            "Should fail to parse invalid address: {addr}"
        );
    }
}
